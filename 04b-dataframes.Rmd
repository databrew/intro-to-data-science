# Dataframes {#dataframes}

### Dataframes & other data structures  {-}

#### Learning goals {-}

* Practice exploring, summarizing, and filtering dataframes
* Understand the importance of *tidy* datasets
* Understand what the `tidyverse` is and why it is awesome

A **vector** is the most basic data structure in `R`, and the other structures are built out of vectors.

As a data scientist, the most common data structure you will be working with is a **dataframe**, which is essentially a spreadsheet: a dataset with rows and columns, in which each column represents is a vector of the same class of data. 

We will explore dataframes in detail later, but here is a sneak peak at what they look like:

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame(x=300:310,
           y=600:610)
df
```

In this command, we used the `data.frame()` function to combine two vectors into a dataframe with two columns named `x` and `y`. `R` then saved this result in a new variable named `df`. When we call `df`, `R` shows us the dataframe.

The great thing about dataframes is that they allow you to relate different data types to each other.

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame(name=c("Ben","Joe","Eric"),
                 height=c(75,73,80))
df
```

This dataframe has one column of class `character` and another of class `numeric`.

Typically you will "read" data into Rstudio from a folder on your computer (to be covered later). However, R (and many R packages) come with built-in, clean data 

To see what's available

```{r,echo=TRUE,collapse=TRUE, eval = FALSE}
data()
```

The two other most common data structures are **matrices** and **lists**, but we will wait on learning about those. For now, focus on becoming comfortable using vectors and dataframes. 

### Exercise 4 {-}

Let's create a new object named `animals`. This is going to be a dataframe with 4 different columns: `species`, `height`, `color`, `veg` (whether or not the animal is a vegetarian). 

### More on dataframes

In data science, the most common data structure you will be using -- by far -- is the **dataframe**. You were introduced to this data structure in Module 10, but a more familiar and detailed orientation is worthwhile. 

## Subsetting & exploring dataframes {-} 

To explore dataframes, let's use a dataset on fuel mileage for all cars sold from 1985 to 2014. 

```{r,echo=TRUE,collapse=TRUE}
# need to install first install.packages('fueleconomy')
library(fueleconomy)
data(vehicles)
head(vehicles)
# View(vehicles)
```

A dataframe has rows of data organized into columns. In this dataframe, each row pertains to a single vehicle make/model -- i.e., a single *observation*. Each column pertains to a single *type* of data. Columns are named in the *header* of the dataframe. 

All the same useful exploration and subsetting functions that applied to vectors now apply to dataframes (see module 10 for a refreshers). In addition to those functions you already know, we've added some new functions to your inventory of useful functions.

### Exploration {-}

```{r,echo=TRUE,collapse=TRUE}
tail(vehicles) # head() and tail() summarize the beginning and end of the object
names(vehicles) # get names of columns

nrow(vehicles) # get number of rows

ncol(vehicles) # get number of columns
```

Note that `length()` does not work the same on dataframes as it does with vectors. In dataframes, `length()` is the equivalent of `ncol()`; it will *not* give you the number of rows in a dataset.

### Checking for NAs {-}

```{r,echo=TRUE,collapse=TRUE, eval=FALSE}
# is.na(vehicles)
any(is.na(vehicles)) # at least one!

# Find the NA
any(is.na(vehicles$id))
any(is.na(vehicles$make))

```


### Subsetting {-}

Recall that dataframes are filtered by row and/or column using this format: **`dataframe[rows,columns]`**. To get the third element of the second column, for example, you type `dataframe[3,2]`.

```{r,echo=TRUE,collapse=TRUE}
vehicles[3,2]
```

Note that the comma is necessary even if you do not want to specify columns. If you try to type this ...

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles[3]
```

...`R` will assume you are asking for the third column, not the third row.  

To filter a dataframe to multiple values, you can specify vectors for the `row` and `column`

```{r,echo=TRUE,collapse=TRUE}
vehicles[1:3,11:12] # can use colons
vehicles[1:3,c(1,11:12)]  # can use c()
```

Columns can also be called according to their names. Use the **`$`** sign to specify a column.

```{r,echo=TRUE,collapse=TRUE}
vehicles$hwy[1:5]
```

Note that when you use a `$`, you will not need to use a comma within your brackets. If you try to run this ...

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles$hwy[1:5,]
```

...`R` will throw a fit.  

You can use logical tests to filter dataframes to rows that meet certain conditions. For example, to filter to only the rows for cars with better than 100 mpg, you can use this syntax:

```{r,echo=TRUE,collapse=TRUE}
keeps <- which(vehicles$hwy > 100)
keeps
vehicles[keeps,]
```

But the above is a long-winded way of doing this. You can also achieve this result as follows:

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles[which(vehicles$hwy > 100),]
```

You can also get the same result without the `which()` function:

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles[vehicles$hwy > 100,]
```

The logical test is returning a bunch of `TRUE`s and `FALSE`s, one for each row of `vehicles`. Only the `TRUE` rows will be returned.  

#### Exercise 1: Reading for errors {-}

What is wrong with these commands? Why will each of them throw an error if you run them, and how can you fix them?

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
# 1
vehicles[1,15,]

# 2
vecihles[1:5,]

# 3
vehicles$hwy[1:5,]

# 4
vehicles[1:5,1:13]
```

### Summarizing {-}

The same summary functions that you have used for vectors work for dataframes, such as:

```{r,echo=TRUE,collapse=TRUE}
min(vehicles$hwy)
max(vehicles$hwy)
mean(vehicles$cty)
sd(vehicles$cty)
str(vehicles$make)
class(vehicles$hwy)
```

You can also use the **`summary()`** function, which provides summary statistics for each column in your dataframe:

```{r,echo=TRUE,collapse=TRUE}
summary(vehicles)
```

The function **`unique()`** returns unique values within a column:

```{r,echo=TRUE,collapse=TRUE}
unique(vehicles$fuel)
```

Finally, the **`order()`** function helps you sort a dataframe according to the values in one of its columns.

```{r,echo=TRUE,collapse=TRUE}
vehicles_sorted <- vehicles[order(vehicles$hwy),  #sort dataframe by highway mileage
                            c(2,3,4,10:12)] # only keep certain columns
head(vehicles_sorted)
```

Reverse the order by wrapping **`rev()`** around the `order()` call:

```{r,echo=TRUE,collapse=TRUE}
vehicles_sorted <- vehicles[rev(order(vehicles$hwy)),
                            c(2,3,4,10:12)]
head(vehicles_sorted)
```


### Building dataframes {-}

To create a new dataframe, use the `data.frame()` function.

```{r,collapse=TRUE}
my_vehicles <- data.frame(car=paste(vehicles$make,vehicles$model),
                          mgp_hwy=vehicles$hwy,
                          mpg_city=vehicles$cty)
my_vehicles[100:106,]
```

Note how the columns were named in the `data.frame()` call, and that each column is separated by a comma.

You can also stage an empty dataframe, which sounds useless but will become very useful as you start working with `for` loops and other higher-order `R` tools.  

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame()
df
```

To coerce an object into a format that `R` interprets as a dataframe, use **`as.dataframe()`**: 

```{r,echo=TRUE,collapse=TRUE}
df <- as.data.frame(vehicles)
df[1:4,1:4]
```

You can bind multiple dataframes together using **`rbind()`**: 

```{r,echo=TRUE,collapse=TRUE}
df1 <- data.frame(name=c("Ben","Joe","Eric","Isabelle"),instrument=c("Nose harp","Concertina","Ukelele","Drums"))
df1

df2 <- data.frame(name=c("Matthew"),instrument=c("Washboard"))
rbind(df1,df2)
```

Note that to be combined, two dataframes have to have the exact same number of columns and the exact same column names.

The only exception to this is adding a dataframe with content an empty dataframe. That can work, and that will be helpful in the *`R` Toolbag* modules ahead.

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame() # stage empty dataframe
df1 <- data.frame(name=c("Ben","Joe","Eric","Isabelle"),instrument=c("Nose harp","Concertina","Ukelele","Drums"))
df <- rbind(df,df1)
df
```

You can also bind multiple dataframes together using **`cbind()`**: 
```{r,echo=TRUE,collapse=TRUE}
df1 <- data.frame(name=c("Ben","Joe","Eric","Isabelle"),instrument=c("Nose harp","Concertina","Ukelele","Drums"))
df <- data.frame(age=c(33,35,35,20), home=c("Canada","Spain","USA","USA"))
df <- cbind(df,df1)
df
```

Note that to be combined, two dataframes have to have the exact same number of rows and the exact same column names.

### Exercise 2: Subsetting and filtering {-}

**A. Subset one field according to a logical test**  
With no more than two lines of code, get the number of Honda cars in the `vehicles` dataset.  

**B. Subset one field according to a logical test for a different field.**  
In a single line of code, show the mileages of all the Toyotas in the dataset.

**C. Subset a dataframe to a single subgroup**  
In a single line of code, determine how many differet car makes/models were produced in 1995.

**D. Get the mean value for a subgroup of data**  
What is the average city mileage for Subaru cars in the dataset?

**E. Subset a dataframe to only data from between two values**  
According to this dataset, how many different car makes/models have been produced with highway mileages between 30 and 40 mpg?

#### Review assignment {-}

1. Create a vector called `people` of 5 peoples names from the class.

2. Show with code how many people are in your vector

3. Create another vector called `height` which is the number of centimeters tall each of those 5 people are.

4. Combine these two vectors into a data frame.

## dplyr {-}

Data scientists largely work in data frames and _do things_ to data. This is what dplyr is optimized for. It consists of a series of "verbs" which cover 95% of what you need to do for most basic data processing tasks. 

#### The verbs {-}

filter()  
arrange()  
select()   
rename()  
distinct()  
mutate()   
summarise()  
sample_n() (and sample_frac())  

#### The pipe

`%>%` is a "pipe". It is a way to write code without so many parenthesis. For example, what if I want to find the square root of the sum of a sample of two integers from a sequence of 10 to 20 by 2:

```{r,echo=TRUE,collapse=TRUE}
sqrt(sum(sample(seq(10, 20, 2), 2)))
```

The above could also be written as:

```{r,echo=TRUE,collapse=TRUE}
library(dplyr)
seq(10, 20, 2) %>% sample(2) %>% sum %>% sqrt
```

Similarly the below:

```{r,echo=TRUE,collapse=TRUE}
mean(sd(log(1:100)))
```

Could also be written as:

```{r,echo=TRUE,collapse=TRUE}
1:100 %>% log %>% sd %>% mean
```

It can be read as "then".

#### Filtering {-}

The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. To be retained, the row must produce a value of TRUE for all conditions. Note that when a condition evaluates to NA the row will be dropped, unlike base subsetting with [.

```{r,echo=TRUE,collapse=TRUE}
library(dplyr)
people <- data.frame(who = c('Joe', 'Ben', 'Xing', 'Coloma'),
                    sex = c('Male', 'Male', 'Female', 'Female'),
                    age = c(35, 33, 32, 34))

men <- people %>%
  filter(sex == 'Male')
women <- people %>%
  filter(sex == 'Male')
```


#### Arranging {-}

Arrange means putting things in order. That is, arrange() orders the rows of a data frame by the values of selected columns.

Unlike other dplyr verbs, arrange() largely ignores grouping; you need to explicitly mention grouping variables (or use .by_group = TRUE) in order to group by them, and functions of variables are evaluated once per data frame, not once per group. For example:

```{r,echo=TRUE,collapse=TRUE}
people %>% arrange(age)

people %>% arrange(sex)

people %>% arrange(who)

people %>% arrange(desc(age))

```

#### Selecting {-}

Select (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name (e.g. a:f selects all columns from a on the left to f on the right). You can also use predicate functions like is.numeric to select variables based on their properties.

```{r,echo=TRUE,collapse=TRUE}
people %>% select(age)

people %>% select(sex, age)

people %>% select(sex, years = age)
```


#### Renaming {-}

rename() changes the names of individual variables using new_name = old_name syntax; rename_with() renames columns using a function.

```{r,echo=TRUE,collapse=TRUE}
people %>% rename(gender = sex, years = age, first_name = who)

```


#### Mutating {-}

mutate() adds new variables and preserves existing ones; transmute() adds new variables and drops existing ones. New variables overwrite existing variables of the same name. Variables can be removed by setting their value to NULL.

```{r,echo=TRUE,collapse=TRUE}
people %>% mutate(agein2020 = age - 1)

people %>% mutate(is_male = sex == 'Male')

people %>% mutate(who = NULL)

people %>% mutate(average_age = mean(age))

people %>% mutate(average_age = mean(age)) %>%
  mutate(diff_from_avg = age - average_age)


```


#### Grouping {-}

Most data operations are done on groups defined by variables. group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed "by group". ungroup() removes grouping.



```{r,echo=TRUE,collapse=TRUE}
people %>% 
  group_by(sex) %>%
  mutate(average_age_for_sex = mean(age)) 

people %>% 
  group_by(sex) %>%
  mutate(average_age_for_sex = mean(age)) %>%
  mutate(diff_from_avg_for_sex = age - average_age_for_sex)
```

#### Summarizing {-} 

summarise() or summarize() creates a new data frame. It will have one (or more) rows for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarising all observations in the input. It will contain one column for each grouping variable and one column for each of the summary statistics that you have specified.

```{r,echo=TRUE,collapse=TRUE}
people %>% 
  summarise(average_age = mean(age))

people %>% 
  summarise(average_age = mean(age),
            standard_dev_of_age = sd(age),
            oldest_age = max(age),
            youngest_age = min(age))

people %>% 
  group_by(sex) %>%
  summarise(avg_age = mean(age),
            oldest_age = max(age),
            total_years = sum(age)) 

people %>%
  group_by(sex) %>%
  summarise(sample_size = n())
```


#### Review exercise {-}


1. Run the below code.

```{r,echo=TRUE,collapse=TRUE}
library(dplyr)
library(babynames)
bn <- babynames
```

2. Crete a dataframe named `turn_of_century. This should be data on baby names for the year 1900

3. Create a dataframe named `boys`. This should be only males

4. Create a dataframe named `moms_gen`. This should be females born in the year of birth of your mom.

5. Order `moms_gen` by `n`, in ascending order (ie, the least popular name at top). Look at the result; what is the least popular name among women the year your mom was born?

6. Reverse the order and save the result into an object named `moms_gen_ordered`.

7. Create an object named `boys2k`. This should be all males born in the year 2000.

8. Arrange `boys2k` from most to least popular. What was the most popular boys name in 2000?

9. What percentage of boys were named `Joseph` in 2000?

10. Were there more Jims or Matthews in 2020?

11. How many people were born with _your_ name in 2020.


#### Team exercises

```{r}
# Load library
library(gsheet)

# Read in data
survey  <- gsheet::gsheet2tbl('https://docs.google.com/spreadsheets/d/1iVt9FX9J2iv3QFKBM7Gzb9dgva70XrW1lxMV4hpekeo/edit?resourcekey#gid=204634767')

# remake the names
names(survey) <- c('time', 'sex', 'age','sib', 'dad_mus', 'person_mus', 'joe_mus_is', 'eyesight', 'height', 'shoe_size', 'bday', 'money_or_love', 'rps_skill', 'num_pan', 'cats_dogs', 'name')

```


1) Subset the data by those older than 20

2) Subset the data by those who think Joe's mustach is "Deeply captivating"

3) Subset the data by those who are taller than 175cm, prefer cats over dogs, and are average at rock, paper, scissors

4) Do more people like cats or dogs?

5) Create a new variable called "std_shoes" that standardizes shoe sizes by converting men's shoe size to womens (There is an approximate 1.5 size difference between Men's and Women's sizing (e.g., a men's size 7 is roughly equivalent to a women's size 8.5)

6) Get the avg shoe size by sex (Male, Female, Prefer not to say) 

7) Average age, height, & number of siblings, by the sex

8) Do people that have ever had a mustache think there will be more pandemics on avg than those who have never had a mustache

9) Do people that prefer cats have smaller feet on average than those who prefer dogs

10) Create a bar chart that compares the average age of those who prefer cats vs dogs

11) Create a scatter plot that shows the relationship between age and height (make it look nice!)

12) Create a scatter plot that shows the relationship between height and shoe size 

13) Create a bar chart that shows the average number of siblings for dad's mustache status.

14) Color the barchart above and add some degree of transparency in the color. Add a title.

15) Create a bar chart that shows the average shoe size by sex and cat/dog preference. 



#### Group activity {-}

Using the `deaths` data, we're going to answer some questions together. Start with:

```{r,echo=TRUE,collapse=TRUE}
library(readr)
library(dplyr)
df <- read_csv('https://raw.githubusercontent.com/databrew/intro-to-data-science/main/data/deaths.csv')
```

1. How many people are in the dataset.

2. Use `summarize` to count the number of men and women.  

3. Use `summarize` to count the number of people in each class.  

4. Use `summarize` to count the number of men and women in each class.  

5. Use `mutate` to create a variable called `died`. This should be a boolean based on the `Survived` column (in which 1 means the person survived, and 0 means the person died).

6. Use `mutate` to create a variable called `child`. This should be a boolean based on the `Age` column, indicating if someone was less than 18 years old.

7. Create a different dataframe for men vs. women. Name them accordingly.

8. Create a different dataframe for class 1, class 2, and class 3. Name them accordingly.

9. For each of the 5 datasets you've just created, what is the death rate?

10. For each of the 5 datasets, how many children died?

11. Now, using the _full_ dataset, calculate the child-specific death rate for each combination of class and sex (ie, "first class females", "third class males", etc.). 

12. What did you find? What might explain that?

```{r,echo=FALSE,collapse=TRUE, eval = FALSE}
# class survey data
library(gsheet)
survey <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1iVt9FX9J2iv3QFKBM7Gzb9dgva70XrW1lxMV4hpekeo/edit?resourcekey#gid=204634767')
```


