--- 
title: "`DataBOOM`: the canon for data science"
author: "Databrew"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: databrew/intro-to-data-science
description: "Data science is just data and science. But it's better with pizza."
favicon: img/favicon.ico
params:
  is_teacher: FALSE
---

# Welcome!

Placeholder


## What this is, and what it isn't {-}
## Who this is for {-}
## What you will learn {-}
## Who we are {-}

<!--chapter:end:index.Rmd-->


# (PART) Core theory {-}
# Principles of data science

Placeholder


## What is data science?   {-}
## Data scientist vs data analysist vs data engineer {-}
## What is the data life cycle?   {-}
## Data science 'in the wild'   {-}
## Why R? {-}
## The reproducibility crisis   {-}

<!--chapter:end:02a-principles.Rmd-->


# Visualizing data {#dataviz}

Placeholder


## The importance of visualization
## Bad examples
## Good exaples
## Quick video

<!--chapter:end:02b-visualizing_data.Rmd-->


# (PART) Getting sta`r`ted {-}
# Setting up `RStudio`

Placeholder



<!--chapter:end:03a-getting_started.Rmd-->


# Running R code

Placeholder


#### Learning goals {-}
## RStudio's *Console* {-}
## Running code in the *Console*  {-}
#### Exercise 1 {-}
### Re-running code in the *Console* {-}
#### Exercise 2 {-}
### Incomplete commands in `R` {-}
### Getting errors in `R` {-}
#### Exercise 3 {-}
## Use R like a calculator {-}
#### Exercise 4 {-}
## Using operators in R {-}
#### Exercise 5 {-}
## Use built-in functions within R {-}
#### Exercise 6 {-}
#### Review assignment: {-}
#### Other Resources {-}

<!--chapter:end:03b-running_code.Rmd-->


# Using `RStudio` and `R` scripts

Placeholder


#### Learning goals {-}
## `R` and `RStudio`: what's the difference? {-}
## Two-minute tour of `RStudio` {-}
### Console  {-}
### Environment  {-}
### Files, Plots, Packages, & Help  {-}
## Scripts  {-}
### Exercise 1 {-}
### What is an `R` script, and why are scripts so awesome? {-}
### Commenting your code {-}
### Saving your work {-}
## Your working directory  {-}
### How to set your working directory {-}
## Typical workflows    {-}
### Template `R` script {-}
#### Review assignment: {-}
#### Other Resources  {-}

<!--chapter:end:03c-rstudio_tour.Rmd-->


# Variables in `R`

Placeholder


#### Learning goals {-}
## Introducing variables {-}
### Declaring variables {-}
### Calling variables {-}
### Naming variables  {-}
#### Naming theory {-}
#### Exercise 1 {-}
## Types of data in `R` {-}
### Exercise 2 {-}
### Exercise 3 {-}
#### Review assignment {-}

<!--chapter:end:03d-objects.Rmd-->


# Structures for data in `R`

Placeholder


#### Learning goals {-}
## Introducing data structures {-}
## Vectors {-}
### Declaring and using vectors {-}
#### Exercise 1 {-}
### Useful functions for handling vectors  {-}
#### Exercise 2 {-}
### Subsetting vectors {-}
#### Exercise 2 {-}
#### Review assignment {-}

<!--chapter:end:03da-data-structure.Rmd-->


# Calling functions {#calling_functions}

Placeholder


#### Learning goals {-}
## Introducing `R` functions {-}
### Base functions in `R` {-}
### Saving function output  {-}
### Functions with multiple inputs {-}
### Function defaults {-}
### Function documentation (i.e., getting help) {-}
### Function examples  {-}
#### Review assignment {-}

<!--chapter:end:03e-call_functions.Rmd-->


# Subsetting and filtering {#subsetting}

Placeholder


#### Learning goals {-}
## A quick review of booleans {-}
### Review assignment {-}

<!--chapter:end:03ex-subsetting.Rmd-->


# Base plots

Placeholder


#### Learning goals {-}
## Introduction  {-}
## Create a basic plot {-}
## Most common types of plots {-}
### Exercise 1 {-}
## Basic plot formatting {-}
### Exercise 2 {-}
## Plotting with data frames {-}
### Exercise 2 {-}
## Next-level plotting {-}
### Adding lines  {-}
#### Exercise 4 {-}
### Adding text {-}
#### Exercise 5 {-}
### Highlighting certain data points {-}
#### Exercise 6 {-}
### Building a plot from the ground up {-}
#### Review assignment {-}
#### Other Resources  {-}

<!--chapter:end:03f-base_plots.Rmd-->


# Packages

Placeholder


#### Learning goals {-}
## Introducing `R` packages {-}
## Finding the packages already on your computer  {-}
## Installing a new package  {-}
### Installing from `CRAN`  {-}
#### Through clicks: {-}
#### Through code: {-}
### Installing from `GitHub`  {-}
## Loading an installed package {-}
## Calling functions from a package  {-}
## Review: the workflow for using a package {-}
## A note on package dependencies {-}
## A note on package versions  {-}
## Review assigment: let's install some packages {-}

<!--chapter:end:03g-packages.Rmd-->


# Basics of `ggplot`

Placeholder


#### Learning goals {-}
## Thinking about data visualization
## What is `ggplot`?  {-}
## The name and concept  {-}
## Practice {-}
## A practical example {-}
## Learning examples {-}
### Perfecting the canvas {-}
### Aesthetic attributes of the geoms {-}
#### Review assignment  {-}
## Other resources  {-}

<!--chapter:end:03h-base_ggplot.Rmd-->


# (PART) Basic `R` workflow {-}
# Importing data

Placeholder


#### Learning goals {-}
## `.csv` files {-}
## Data format requirements {-}
### Workflow for formatting your data {-}
## Reading in data {-}
### Core functions for reading data {-} 
####  `read.csv()` {-}
#### `readr::read_csv()` {-}
#### `readRDS()` {-}
### Reading data from other folders {-}
### Managing files {-}
#### Review exercise {-}

<!--chapter:end:04a-importing_data.Rmd-->

# Dataframes {#dataframes}

### Dataframes & other data structures  {-}

#### Learning goals {-}

* Practice exploring, summarizing, and filtering dataframes
* Understand the importance of *tidy* datasets
* Understand what the `tidyverse` is and why it is awesome

A **vector** is the most basic data structure in `R`, and the other structures are built out of vectors.

As a data scientist, the most common data structure you will be working with is a **dataframe**, which is essentially a spreadsheet: a dataset with rows and columns, in which each column represents is a vector of the same class of data. 

We will explore dataframes in detail later, but here is a sneak peak at what they look like:

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame(x=300:310,
           y=600:610)
df
```

In this command, we used the `data.frame()` function to combine two vectors into a dataframe with two columns named `x` and `y`. `R` then saved this result in a new variable named `df`. When we call `df`, `R` shows us the dataframe.

The great thing about dataframes is that they allow you to relate different data types to each other.

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame(name=c("Ben","Joe","Eric"),
                 height=c(75,73,80))
df
```

This dataframe has one column of class `character` and another of class `numeric`.

Typically you will "read" data into Rstudio from a folder on your computer (to be covered later). However, R (and many R packages) come with built-in, clean data 

To see what's available

```{r,echo=TRUE,collapse=TRUE, eval = FALSE}
data()
```

The two other most common data structures are **matrices** and **lists**, but we will wait on learning about those. For now, focus on becoming comfortable using vectors and dataframes. 

### Exercise 4 {-}

Let's create a new object named `animals`. This is going to be a dataframe with 4 different columns: `species`, `height`, `color`, `veg` (whether or not the animal is a vegetarian). 

### More on dataframes

In data science, the most common data structure you will be using -- by far -- is the **dataframe**. You were introduced to this data structure in Module 10, but a more familiar and detailed orientation is worthwhile. 

## Subsetting & exploring dataframes {-} 

To explore dataframes, let's use a dataset on fuel mileage for all cars sold from 1985 to 2014. 

```{r,echo=TRUE,collapse=TRUE}
# need to install first install.packages('fueleconomy')
library(fueleconomy)
data(vehicles)
head(vehicles)
# View(vehicles)
```

A dataframe has rows of data organized into columns. In this dataframe, each row pertains to a single vehicle make/model -- i.e., a single *observation*. Each column pertains to a single *type* of data. Columns are named in the *header* of the dataframe. 

All the same useful exploration and subsetting functions that applied to vectors now apply to dataframes (see module 10 for a refreshers). In addition to those functions you already know, we've added some new functions to your inventory of useful functions.

### Exploration {-}

```{r,echo=TRUE,collapse=TRUE}
tail(vehicles) # head() and tail() summarize the beginning and end of the object
names(vehicles) # get names of columns

nrow(vehicles) # get number of rows

ncol(vehicles) # get number of columns
```

Note that `length()` does not work the same on dataframes as it does with vectors. In dataframes, `length()` is the equivalent of `ncol()`; it will *not* give you the number of rows in a dataset.

### Checking for NAs {-}

```{r,echo=TRUE,collapse=TRUE}
is.na(vehicles)
any(is.na(vehicles)) # at least one!

# Find the NA
any(is.na(vehicles$id))
any(is.na(vehicles$make))

```


### Subsetting {-}

Recall that dataframes are filtered by row and/or column using this format: **`dataframe[rows,columns]`**. To get the third element of the second column, for example, you type `dataframe[3,2]`.

```{r,echo=TRUE,collapse=TRUE}
vehicles[3,2]
```

Note that the comma is necessary even if you do not want to specify columns. If you try to type this ...

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles[3]
```

...`R` will assume you are asking for the third column, not the third row.  

To filter a dataframe to multiple values, you can specify vectors for the `row` and `column`

```{r,echo=TRUE,collapse=TRUE}
vehicles[1:3,11:12] # can use colons
vehicles[1:3,c(1,11:12)]  # can use c()
```

Columns can also be called according to their names. Use the **`$`** sign to specify a column.

```{r,echo=TRUE,collapse=TRUE}
vehicles$hwy[1:5]
```

Note that when you use a `$`, you will not need to use a comma within your brackets. If you try to run this ...

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles$hwy[1:5,]
```

...`R` will throw a fit.  

You can use logical tests to filter dataframes to rows that meet certain conditions. For example, to filter to only the rows for cars with better than 100 mpg, you can use this syntax:

```{r,echo=TRUE,collapse=TRUE}
keeps <- which(vehicles$hwy > 100)
keeps
vehicles[keeps,]
```

But the above is a long-winded way of doing this. You can also achieve this result as follows:

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles[which(vehicles$hwy > 100),]
```

You can also get the same result without the `which()` function:

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
vehicles[vehicles$hwy > 100,]
```

The logical test is returning a bunch of `TRUE`s and `FALSE`s, one for each row of `vehicles`. Only the `TRUE` rows will be returned.  

#### Exercise 1: Reading for errors {-}

What is wrong with these commands? Why will each of them throw an error if you run them, and how can you fix them?

```{r,echo=TRUE,eval=FALSE,collapse=TRUE}
# 1
vehicles[1,15,]

# 2
vecihles[1:5,]

# 3
vehicles$hwy[1:5,]

# 4
vehicles[1:5,1:13]
```

### Summarizing {-}

The same summary functions that you have used for vectors work for dataframes, such as:

```{r,echo=TRUE,collapse=TRUE}
min(vehicles$hwy)
max(vehicles$hwy)
mean(vehicles$cty)
sd(vehicles$cty)
str(vehicles$make)
class(vehicles$hwy)
```

You can also use the **`summary()`** function, which provides summary statistics for each column in your dataframe:

```{r,echo=TRUE,collapse=TRUE}
summary(vehicles)
```

The function **`unique()`** returns unique values within a column:

```{r,echo=TRUE,collapse=TRUE}
unique(vehicles$fuel)
```

Finally, the **`order()`** function helps you sort a dataframe according to the values in one of its columns.

```{r,echo=TRUE,collapse=TRUE}
vehicles_sorted <- vehicles[order(vehicles$hwy),  #sort dataframe by highway mileage
                            c(2,3,4,10:12)] # only keep certain columns
head(vehicles_sorted)
```

Reverse the order by wrapping **`rev()`** around the `order()` call:

```{r,echo=TRUE,collapse=TRUE}
vehicles_sorted <- vehicles[rev(order(vehicles$hwy)),
                            c(2,3,4,10:12)]
head(vehicles_sorted)
```


### Building dataframes {-}

To create a new dataframe, use the `data.frame()` function.

```{r,collapse=TRUE}
my_vehicles <- data.frame(car=paste(vehicles$make,vehicles$model),
                          mgp_hwy=vehicles$hwy,
                          mpg_city=vehicles$cty)
my_vehicles[100:106,]
```

Note how the columns were named in the `data.frame()` call, and that each column is separated by a comma.

You can also stage an empty dataframe, which sounds useless but will become very useful as you start working with `for` loops and other higher-order `R` tools.  

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame()
df
```

To coerce an object into a format that `R` interprets as a dataframe, use **`as.dataframe()`**: 

```{r,echo=TRUE,collapse=TRUE}
df <- as.data.frame(vehicles)
df[1:4,1:4]
```

You can bind multiple dataframes together using **`rbind()`**: 

```{r,echo=TRUE,collapse=TRUE}
df1 <- data.frame(name=c("Ben","Joe","Eric","Isabelle"),instrument=c("Nose harp","Concertina","Ukelele","Drums"))
df1

df2 <- data.frame(name=c("Matthew"),instrument=c("Washboard"))
rbind(df1,df2)
```

Note that to be combined, two dataframes have to have the exact same number of columns and the exact same column names.

The only exception to this is adding a dataframe with content an empty dataframe. That can work, and that will be helpful in the *`R` Toolbag* modules ahead.

```{r,echo=TRUE,collapse=TRUE}
df <- data.frame() # stage empty dataframe
df1 <- data.frame(name=c("Ben","Joe","Eric","Isabelle"),instrument=c("Nose harp","Concertina","Ukelele","Drums"))
df <- rbind(df,df1)
df
```

You can also bind multiple dataframes together using **`cbind()`**: 
```{r,echo=TRUE,collapse=TRUE}
df1 <- data.frame(name=c("Ben","Joe","Eric","Isabelle"),instrument=c("Nose harp","Concertina","Ukelele","Drums"))
df <- data.frame(age=c(33,35,35,20), home=c("Canada","Spain","USA","USA"))
df <- cbind(df,df1)
df
```

Note that to be combined, two dataframes have to have the exact same number of rows and the exact same column names.

### Exercise 2: Subsetting and filtering {-}

**A. Subset one field according to a logical test**  
With no more than two lines of code, get the number of Honda cars in the `vehicles` dataset.  

**B. Subset one field according to a logical test for a different field.**  
In a single line of code, show the mileages of all the Toyotas in the dataset.

**C. Subset a dataframe to a single subgroup**  
In a single line of code, determine how many differet car makes/models were produced in 1995.

**D. Get the mean value for a subgroup of data**  
What is the average city mileage for Subaru cars in the dataset?

**E. Subset a dataframe to only data from between two values**  
According to this dataset, how many different car makes/models have been produced with highway mileages between 30 and 40 mpg?

#### Review assignment {-}

1. Create a vector called `people` of 5 peoples names from the class.

2. Show with code how many people are in your vector

3. Create another vector called `height` which is the number of centimeters tall each of those 5 people are.

4. Combine these two vectors into a data frame.

## dplyr {-}

Data scientists largely work in data frames and _do things_ to data. This is what dplyr is optimized for. It consists of a series of "verbs" which cover 95% of what you need to do for most basic data processing tasks. 

#### The verbs {-}

filter()  
arrange()  
select()   
rename()  
distinct()  
mutate()   
summarise()  
sample_n() (and sample_frac())  

#### The pipe

`%>%` is a "pipe". It is a way to write code without so many parenthesis. For example, what if I want to find the square root of the sum of a sample of two integers from a sequence of 10 to 20 by 2:

```{r,echo=TRUE,collapse=TRUE}
sqrt(sum(sample(seq(10, 20, 2), 2)))
```

The above could also be written as:

```{r,echo=TRUE,collapse=TRUE}
library(dplyr)
seq(10, 20, 2) %>% sample(2) %>% sum %>% sqrt
```

Similarly the below:

```{r,echo=TRUE,collapse=TRUE}
mean(sd(log(1:100)))
```

Could also be written as:

```{r,echo=TRUE,collapse=TRUE}
1:100 %>% log %>% sd %>% mean
```

It can be read as "then".

#### Filtering {-}

The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. To be retained, the row must produce a value of TRUE for all conditions. Note that when a condition evaluates to NA the row will be dropped, unlike base subsetting with [.

```{r,echo=TRUE,collapse=TRUE}
library(dplyr)
people <- data.frame(who = c('Joe', 'Ben', 'Xing', 'Coloma'),
                    sex = c('Male', 'Male', 'Female', 'Female'),
                    age = c(35, 33, 32, 34))

men <- people %>%
  filter(sex == 'Male')
women <- people %>%
  filter(sex == 'Male')
```


#### Arranging {-}

Arrange means putting things in order. That is, arrange() orders the rows of a data frame by the values of selected columns.

Unlike other dplyr verbs, arrange() largely ignores grouping; you need to explicitly mention grouping variables (or use .by_group = TRUE) in order to group by them, and functions of variables are evaluated once per data frame, not once per group. For example:

```{r,echo=TRUE,collapse=TRUE}
people %>% arrange(age)

people %>% arrange(sex)

people %>% arrange(who)

people %>% arrange(desc(age))

```

#### Selecting {-}

Select (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name (e.g. a:f selects all columns from a on the left to f on the right). You can also use predicate functions like is.numeric to select variables based on their properties.

```{r,echo=TRUE,collapse=TRUE}
people %>% select(age)

people %>% select(sex, age)

people %>% select(sex, years = age)
```


#### Renaming {-}

rename() changes the names of individual variables using new_name = old_name syntax; rename_with() renames columns using a function.

```{r,echo=TRUE,collapse=TRUE}
people %>% rename(gender = sex, years = age, first_name = who)

```


#### Mutating {-}

mutate() adds new variables and preserves existing ones; transmute() adds new variables and drops existing ones. New variables overwrite existing variables of the same name. Variables can be removed by setting their value to NULL.

```{r,echo=TRUE,collapse=TRUE}
people %>% mutate(agein2020 = age - 1)

people %>% mutate(is_male = sex == 'Male')

people %>% mutate(who = NULL)

people %>% mutate(average_age = mean(age))

people %>% mutate(average_age = mean(age)) %>%
  mutate(diff_from_avg = age - average_age)


```


#### Grouping {-}

Most data operations are done on groups defined by variables. group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed "by group". ungroup() removes grouping.



```{r,echo=TRUE,collapse=TRUE}
people %>% 
  group_by(sex) %>%
  mutate(average_age_for_sex = mean(age)) 

people %>% 
  group_by(sex) %>%
  mutate(average_age_for_sex = mean(age)) %>%
  mutate(diff_from_avg_for_sex = age - average_age_for_sex)
```

#### Summarizing {-} 

summarise() or summarize() creates a new data frame. It will have one (or more) rows for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarising all observations in the input. It will contain one column for each grouping variable and one column for each of the summary statistics that you have specified.

```{r,echo=TRUE,collapse=TRUE}
people %>% 
  summarise(average_age = mean(age))

people %>% 
  summarise(average_age = mean(age),
            standard_dev_of_age = sd(age),
            oldest_age = max(age),
            youngest_age = min(age))

people %>% 
  group_by(sex) %>%
  summarise(avg_age = mean(age),
            oldest_age = max(age),
            total_years = sum(age)) 

people %>%
  group_by(sex) %>%
  summarise(sample_size = n())
```


#### Review exercise {-}


1. Run the below code.

```{r,echo=TRUE,collapse=TRUE}
library(dplyr)
library(babynames)
bn <- babynames
```

2. Crete a dataframe named `turn_of_century. This should be data on baby names for the year 1900

3. Create a dataframe named `boys`. This should be only males

4. Create a dataframe named `moms_gen`. This should be females born in the year of birth of your mom.

5. Order `moms_gen` by `n`, in ascending order (ie, the least popular name at top). Look at the result; what is the least popular name among women the year your mom was born?

6. Reverse the order and save the result into an object named `moms_gen_ordered`.

7. Create an object named `boys2k`. This should be all males born in the year 2000.

8. Arrange `boys2k` from most to least popular. What was the most popular boys name in 2000?

9. What percentage of boys were named `Joseph` in 2000?

10. Were there more Jims or Matthews in 2020?

11. How many people were born with _your_ name in 2020.

#### Group activity {-}

Using the `deaths` data, we're going to answer some questions together. Start with:

```{r,echo=TRUE,collapse=TRUE}
library(readr)
df <- read_csv('https://raw.githubusercontent.com/databrew/intro-to-data-science/main/data/deaths.csv')
```

```{r,echo=TRUE,collapse=TRUE}
library(gsheet)
survey <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1iVt9FX9J2iv3QFKBM7Gzb9dgva70XrW1lxMV4hpekeo/edit?resourcekey#gid=204634767')
```



<!--chapter:end:04b-dataframes.Rmd-->


# Exporting data & plots

Placeholder


#### Learning goals {-}
## `write.csv()` {-}
## `saveRDS()` {-}
## `pdf()` and `png()`  {-}

<!--chapter:end:04d-exporting.Rmd-->


# Exploring data 

Placeholder


#### Learning goals {-}
## Exploring distributions {-}
### Histograms {-}
#### Prettifying histograms {-}
#### Histograms in `ggplot2` {-}
### Violin Plots {-}
## Descriptive statistics {-} 
#### Review exercise {-}
##### Task 1 {-}
##### Task 2 {-}
##### Task 3 {-}

<!--chapter:end:05a-EDA.Rmd-->


# Significance statistics

Placeholder


#### Learning goals {-}
## p-values  {-}
## Tests for different data types {-}
## Comparison tests {-} 
### Influence of sample size {-}
### Comparing more than two groups {-} 
### Comparing categorical counts {-}
## Tests of association {-}
## Reporting results {-}  
#### Review exercise {-}
##### Task 1 {-} 
##### Task 2 {-} 
##### Task 3 {-} 

<!--chapter:end:05b-statistics.Rmd-->


# (PART) Essential `R` skills {-}
# Joining datasets {#joining_datasets}

Placeholder


#### Learning goals {-}
## Joining: the basics {-}
#### Review exercise {-}

<!--chapter:end:07a-joining-data.Rmd-->


# Writing functions

Placeholder


#### Learning goals {-}
## First steps  {-}
### Exercise 1 {-}
## Next steps {-}
### Multiple inputs {-}
### Providing defaults for inputs {-}
#### `NULL` as a default {-}
### Complex inputs {-}
### Complex function outputs {-}
### Adding plots {-}
### Exercise 2 {-}
## Sourcing functions  {-}
### Exercise 3 {-}
#### Review assignment: Baby names over time {-}

<!--chapter:end:07b-writing_functions.Rmd-->


# `for` loops

Placeholder


#### Learning goals {-}
## Basics  {-}
### Exercise 1 {-}
## `for` loops in plots {-}
### Efficient multi-panel plots {-}
### Using `for` loops to plot subgroups of data {-}
### Exercise 3 {-}
### Using `for` loops to layer cyclical or repetitive data  {-}
## Using `for` loops to process & summarize data {-}
### Using `for` loops to summarize data subgroups  {-}  
#### Example use cases {-}
#### Workflow  {-}
#### Example  {-}
### Nested `for` loops   {-}
### Exercise 2 {-}
#### Review assignment {-}
##### Summarize columns with a `for loop` {-}
##### Multi-pane plots with `for loops` {-}
###### Practice with a single plot {-}
#### Now loop it! {-}
###### Now loop it *in layers!* {-}

<!--chapter:end:07c-for_loops.Rmd-->


# Conditional statements

Placeholder


#### Learning goals {-}
## First steps  {-}
### Exercise 1 {-}
## Next steps {-}  
### Nested conditions {-} 
### Handling `NA`s, `NaN`'s, `Inf`s, and `NULL`s {-}
### Joint conditions {-} 
### Exercise 2 {-}
#### Review assignment {-}

<!--chapter:end:07d-conditional_statements.Rmd-->


# Working with text {#text}

Placeholder


#### Learning goals {-}
## Basics {-}
## Common tools {-}
#### Review assignment {-}

<!--chapter:end:07de-working_with_text.Rmd-->

# Working with dates & times


<!--chapter:end:07e-working_with_dates.Rmd-->

# Working with factors


<!--chapter:end:07f-working_with_factors.Rmd-->


# Matrices & lists

Placeholder


#### Learning goals {-}
## Lists {-} 
### Use cases for lists {-}
## Matrices {-}
### Use cases for matrices {-}
#### Review exercise {-}
##### Task 1 {-}  
##### Task 2 {-}  

<!--chapter:end:07g-matrices_lists.Rmd-->


# Cleaning messy data

Placeholder


#### Learning goals {-}
### Your mission {-}

<!--chapter:end:07h-cleaning_messy_data.Rmd-->

# Excel files & GoogleSheets

#### Learning goals {-}









<!--chapter:end:07j-excel_gsheets.Rmd-->

# (PART) Interactive dashboards {-}

# Intro to Shiny apps


<!--chapter:end:08a-shiny_apps.Rmd-->

# Shiny dashboards




<!--chapter:end:08b-shiny_dashboards.Rmd-->

# Data entry apps


<!--chapter:end:08c-data_entry.Rmd-->

# (PART) Databases {-}

# Introduction


## What
## Why 
## When 
## When not


<!--chapter:end:09a-intro_to_databases.Rmd-->

# Platforms

## PostgreSQL
## mySQL
## SQLite




<!--chapter:end:09b-database_platforms.Rmd-->

# Alternatives

## NoSQL



<!--chapter:end:09c-database_alternatives.Rmd-->

# Practices

Spinning up a local DB



<!--chapter:end:09d-database_practices.Rmd-->

# (PART) Documenting your work {-}

# R Markdown



<!--chapter:end:10a-R_Markdown.Rmd-->

# Reproducible research

<!--chapter:end:10b_reproducible_research.Rmd-->

# Automated reporting




<!--chapter:end:10c-automated_reporting.Rmd-->

# Formatting standards

## Tables
## Figures
## Captions



<!--chapter:end:10d-formatting_standards.Rmd-->


# Git 

Placeholder


## There is a better way  {-}
## What is git?  {-}
## Why?  {-}
## Get ready for git  {-}
## Installation  {-}
### Windows {-}
### Mac {-}
## Getting to know git bash {-}
#### pwd {-}
#### ls {-}
#### cd {-}
## Configuration  {-}
## Github  {-}
### Creating a repository  {-}
### Cloning a repository  {-}
### Writing some code  {-}
## A bit more practice  {-}
### Creating another repo  {-}
### The `.gitignore`  {-}
## Advanced git  {-}

<!--chapter:end:11b-git.Rmd-->


# (PART) Sharing research {-}
# Sections of a report

Placeholder


#### Learning goals {-}
## Overall structure  {-}
## Abstract {-}
#### Standards {-}
#### Strategies {-} 
#### Good example {-}
## Introduction {-}
#### Standards {-}
#### Strategies {-} 
##### 1. Conducting a literature review {-}
##### 2. Organizing and writing your Introduction {-}
## Methods {-}
#### Standards {-}
#### Strategies {-} 
## Results {-}
#### Standards {-}
#### Strategies {-} 
## Discussion {-}
#### Standards {-}
## Other elements of a report {-}
#### Acknowledgments {-}
#### Literature Cited {-}  
#### Tables {-}  
#### Figures {-}  
#### Other resources {-}

<!--chapter:end:12b-sections.Rmd-->


# Formatting, structure & style {#style}

Placeholder


#### Learning goals {-}
## Core principles {-}
## Further considerations {-}
### Sharp & precise writing {-}
### Use of passive voice and first-person {-}
## Logistics of scientific writing {-}  
### Writing about results {-}
### Captions for tables and figures {-}  
### Referencing tables & figures {-}
### Citing references {-}
### Formatting *Literature Cited* {-}  
#### In-line citations {-}  
#### Bibliographic entry {-}    
## Formatting tables {-}
## Formatting figures {-}  
### Plots {-}
### Maps {-}
### Diagrams {-}  

<!--chapter:end:12c-style.Rmd-->


# Presentations

Placeholder


### Standards for all presentations {-}   
#### Content & substance {-}
##### First moments {-}  
##### Early audience orientation {-}  
##### Research & evidence {-}  
##### Story & narrative {-}  
##### Relevance & Importance {-}  
##### Pre- & Misconceptions {-} 
##### Final moments {-}
##### Organization overall {-}
#### Delivery & style {-}
##### Preparation {-} 
##### Speech {-} 
##### Language {-} 
##### Explanation {-} 
##### Non-verbal delivery: The “Second Conversation” {-}  
##### Mistakes {-}  
##### Attentive, responsive, & adaptive {-}
#### Rapport & Relating  {-}
##### Energetic & credible {-}
##### Human & relatable {-}  
##### Inclusive & welcoming {-}
#### Visual aids {-}
##### Strategic use {-} 
##### Design & display {-} 
##### Visualizing information {-}
### Talking to the public {-}  

<!--chapter:end:12d-presentations.Rmd-->

# Creating websites {-}

<!--chapter:end:13a-websites.Rmd-->

# (PART) Advanced skills {-}

# Mapping

<!--chapter:end:14-mapping.Rmd-->

# Geographic computing & GIS


<!--chapter:end:15-gis.Rmd-->

# Statistical modeling


<!--chapter:end:16-modeling.Rmd-->

# Apply family



<!--chapter:end:17-apply.Rmd-->


# Randomization statistics

Placeholder


#### Learning goals {-}
## Basic idea {-}
### Generalized randomization workflow {-}
## Common use cases {-}
### 1. Is outcome `X` significantly unexpected? {-}
### 2. Are two sample sets significantly different? {-}
### 3. Are two variables correlated? {-}
### 4. Is the slope of a regression line negative? {-}
## Review assignment {-}
### (a) Do bubble net feeders have stronger social bonds? {-}
### (b) Are bubble net feeders more closely related to each other? {-}
## (c) Do social bonds relate to kinship? {-}

<!--chapter:end:18-iterative.Rmd-->

# Iterative simulations



<!--chapter:end:19-simulations.Rmd-->

# Image analysis


<!--chapter:end:20-Image_analysis.Rmd-->

# Machine learning

<!--chapter:end:21-Machine_learning.Rmd-->

`r if (knitr:::is_html_output()) '
# References {-}
'`

<!--chapter:end:22-references.Rmd-->

