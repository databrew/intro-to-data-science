# Dataframes: Mastery {#dataframes}

#### Learning goals {-}

* Understand the importance of *tidy* dataframes
* Understand what the `tidyverse` is and why it is awesome
* Feel comfortable working with dataframes using `dplyr` functions.


## The `dplyr` package {-}

Data scientists largely work in data frames and _do things_ to data. This is what the package `dplyr` is optimized for. It consists of a series of "verbs" which cover 95% of what you need to do for most basic data processing tasks. 

```{r,echo=TRUE,collapse=TRUE,eval=FALSE}
install.packages('dplyr')
```

```{r,echo=TRUE,message=FALSE}
library(dplyr)
```

The `dplyr` package contains a set of `verbs`: things you do to dataframes. Those verbs are:

- **`filter()`**  
- **`arrange()`**  
- **`select()`**   
- **`rename()`**  
- **`distinct()`**  
- **`mutate()`**   
- **`summarise()`**  
- **`sample_n()`** (and **`sample_frac()`**)  

## The `%>%` pipe {-}

**`%>%`** is a "pipe". It is a way to write code without so many parentheses. For example, what if I want to find the square root of the sum of a sample of two integers from a sequence of 10 to 20 by 2:

```{r,echo=TRUE,collapse=TRUE}
sqrt(sum(sample(seq(10, 20, 2), 2)))
```

The above could also be written as:

```{r,echo=TRUE,collapse=TRUE}
seq(10, 20, 2) %>% sample(2) %>% sum %>% sqrt
```

When you see the **`%>%`** pipe symbol, think of the word **"then"**. 

The above code could be read aloud like so: "First, get a sequence of every second numbers between 10 and 20. **Then**, take two random samples from that sequence. **Then**, sum those samples together. **Then**, take the square root of the sum." 

Using the `%>%` pipe framework, your code turns from a nonlinear series of parentheses and brackets to a linear progression of steps. 

Here's another example:

```{r,echo=TRUE,collapse=TRUE}
mean(sd(log(1:100)))
```

... could also be written as:

```{r,echo=TRUE,collapse=TRUE}
1:100 %>% log %>% sd %>% mean
```

## `dplyr` verbs {-}

### `filter()` {-}

The `filter()` function is used to subset a dataframe, retaining all rows that satisfy your conditions. To be retained, the row must produce a value of `TRUE` for all conditions. Note that when a condition evaluates to `NA` the row will be dropped, unlike base subsetting with `[ ... ]`.

```{r,echo=TRUE,collapse=TRUE}
people <- data.frame(who = c('Joe', 'Ben', 'Xing', 'Coloma'),
                    sex = c('Male', 'Male', 'Female', 'Female'),
                    age = c(35, 33, 32, 34))
people
```

```{r,echo=TRUE,collapse=TRUE}
people %>% filter(sex == 'Male')
```

```{r,echo=TRUE,collapse=TRUE}
people %>% filter(sex == 'Female')
```

### `arrange()` {-}

Arrange means putting things in order. That is, `arrange()` orders the rows of a data frame by the values of selected columns.

Unlike other dplyr verbs, arrange() largely ignores grouping; you need to explicitly mention grouping variables (or use .by_group = TRUE) in order to group by them, and functions of variables are evaluated once per data frame, not once per group. For example:

```{r,echo=TRUE,collapse=TRUE}
people %>% arrange(age)

people %>% arrange(sex)

people %>% arrange(who)

# Reverse the order
people %>% arrange(desc(age))

```

### `select()` {-}

Select (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name (e.g. a:f selects all columns from a on the left to f on the right). You can also use predicate functions like is.numeric to select variables based on their properties.

```{r,echo=TRUE,collapse=TRUE}
people %>% select(age)
```

```{r,echo=TRUE,collapse=TRUE}
people %>% select(sex, age)
```

```{r,echo=TRUE,collapse=TRUE}
people %>% select(sex, years = age)
```


### `rename()` {-}

The function `rename()` changes the names of individual variables using new_name = old_name syntax; `rename_with()` renames columns using a function.

```{r,echo=TRUE,collapse=TRUE}
people %>% rename(gender = sex, years = age, first_name = who)
```


### `mutate()` {-}

The function `mutate()` adds new variables and preserves existing ones; `transmute()` adds new variables and drops existing ones. New variables overwrite existing variables of the same name. Variables can be removed by setting their value to NULL.

```{r,echo=TRUE,collapse=TRUE}
people %>% mutate(agein2020 = age - 1)
```

```{r,echo=TRUE,collapse=TRUE}
people %>% mutate(is_male = sex == 'Male')
```

```{r,echo=TRUE,collapse=TRUE}
people %>% mutate(who = NULL)
```

```{r,echo=TRUE,collapse=TRUE}
people %>% mutate(average_age = mean(age))
```

```{r,echo=TRUE,collapse=TRUE}
people %>% mutate(average_age = mean(age)) %>%
  mutate(diff_from_avg = age - average_age)
```


### `group_by()` {-}

Most data operations are done on groups defined by variables. The function `group_by()` takes an existing table and converts it into a grouped tbl where operations are performed "by group". `ungroup()` removes grouping.

```{r,echo=TRUE,collapse=TRUE}
people %>% 
  group_by(sex) %>%
  mutate(average_age_for_sex = mean(age)) 
```

```{r,echo=TRUE,collapse=TRUE}
people %>% 
  group_by(sex) %>%
  mutate(average_age_for_sex = mean(age)) %>%
  mutate(diff_from_avg_for_sex = age - average_age_for_sex)
```

### `summarize()` {-} 

`summarize()` or `summarize()` creates a new data frame. It will have one (or more) rows for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarizing all observations in the input. It will contain one column for each grouping variable and one column for each of the summary statistics that you have specified.

```{r,echo=TRUE,collapse=TRUE}
people %>% 
  summarize(average_age = mean(age))
```

```{r,echo=TRUE,collapse=TRUE}
people %>% 
  summarize(average_age = mean(age),
            standard_dev_of_age = sd(age),
            oldest_age = max(age),
            youngest_age = min(age))
```

```{r,echo=TRUE,collapse=TRUE}
people %>% 
  group_by(sex) %>%
  summarise(avg_age = mean(age),
            oldest_age = max(age),
            total_years = sum(age)) 
```

```{r,echo=TRUE,collapse=TRUE}
people %>%
  group_by(sex) %>%
  summarise(sample_size = n())
```


#### Review exercise {-}


1. Run the below code.

```{r,echo=TRUE,collapse=TRUE}
library(dplyr)
library(babynames)
bn <- babynames
```

2. Crete a dataframe named `turn_of_century. This should be data on baby names for the year 1900

3. Create a dataframe named `boys`. This should be only males

4. Create a dataframe named `moms_gen`. This should be females born in the year of birth of your mom.

5. Order `moms_gen` by `n`, in ascending order (ie, the least popular name at top). Look at the result; what is the least popular name among women the year your mom was born?

6. Reverse the order and save the result into an object named `moms_gen_ordered`.

7. Create an object named `boys2k`. This should be all males born in the year 2000.

8. Arrange `boys2k` from most to least popular. What was the most popular boys name in 2000?

9. What percentage of boys were named `Joseph` in 2000?

10. Were there more Jims or Matthews in 2020?

11. How many people were born with _your_ name in 2020.


#### Group activity {-}

Using the `deaths` data, we're going to answer some questions together. Start with:

```{r,echo=TRUE,collapse=TRUE}
library(readr)
library(dplyr)
df <- read_csv('https://raw.githubusercontent.com/databrew/intro-to-data-science/main/data/deaths.csv')
```

1. How many people are in the dataset.

2. Use `summarize` to count the number of men and women.  

3. Use `summarize` to count the number of people in each class.  

4. Use `summarize` to count the number of men and women in each class.  

5. Use `mutate` to create a variable called `died`. This should be a boolean based on the `Survived` column (in which 1 means the person survived, and 0 means the person died).

6. Use `mutate` to create a variable called `child`. This should be a boolean based on the `Age` column, indicating if someone was less than 18 years old.

7. Create a different dataframe for men vs. women. Name them accordingly.

8. Create a different dataframe for class 1, class 2, and class 3. Name them accordingly.

9. For each of the 5 datasets you've just created, what is the death rate?

10. For each of the 5 datasets, how many children died?

11. Now, using the _full_ dataset, calculate the child-specific death rate for each combination of class and sex (ie, "first class females", "third class males", etc.). 

12. What did you find? What might explain that?


#### Team exercises {-}

Before getting started, start a new script (ctrl + shift + n), name it `survey_exercises.R`, and copy-paste the following code at the top.

```{r,echo=TRUE,collapse=TRUE, eval = FALSE}
# Load library
library(gsheet)
library(dplyr)

# Read in data
survey  <- gsheet::gsheet2tbl('https://docs.google.com/spreadsheets/d/1iVt9FX9J2iv3QFKBM7Gzb9dgva70XrW1lxMV4hpekeo/edit?resourcekey#gid=204634767')

# remake the names
names(survey) <- c('time', 'sex', 'age','sib', 'dad_mus', 'person_mus', 'joe_mus_is', 'eyesight', 'height', 'shoe_size', 'bday', 'money_or_love', 'rps_skill', 'num_pan', 'cats_dogs', 'name')

```


1) Create a dataframe called `old_people`. This should include only people older than 20. Write code to calculate the number rows in your new dataframe.

2) Create a dataframe called `captivated`. This should include all those people who find Joe's moustache to be "deeply captivating". Write code to calculate the number rows in your new dataframe.


3) Create a dataframe called `special_people`. This should be people who are taller than 175cm, prefer cats over dogs, and consider themselves to be average at rock, paper, scissors.

4) In the full dataset (survey), do more people like cats or dogs? What about among "special" people?

5) Create a new variable in `survey` called "std_shoes" that standardizes shoe sizes by converting men's shoe size to women's (There is an approximate 1.5 size difference between Men's and Women's sizing (e.g., a men's size 7 is roughly equivalent to a women's size 8.5)

6) Get the avg shoe size by sex (Male, Female, Prefer not to say) 

7) Get Average age, height, & number of siblings, by the sex

8) Do people that have ever had a mustache think there will be more pandemics on average than those who have never had a mustache?

9) Do people that prefer cats have smaller feet on average than those who prefer dogs?

10) Is eyesight associated with moustache perception?

11) What percentage of people think they are better than average at rock scissors paper?

12) What percentage of men and women think they are better than average at rock scissors paper?

13) How many people think money matters more than love?

14) Create a dataframe, grouped by whether or not people's dads had moustaches, with variables showing each of the following: the maximum age, maximum height,minimum number of pandemics, and average number of siblings

15) What percentage of men have terrible eyesight?

16) How many women have a shoe size of 9 or more?

17) Create a variable in the `survey` dataset named `days_old`. Use the `bday` variable and subtract it from `Sys.Date()`.

18) What is the standard deviation of age?

19) Create a one-column dataset which contains the name(s) of the person(s) with the most number of siblings (hint: use the following dplyr verbs in this order: `filter`, `select`).

20) Tell me something interesting about this dataset. 

```{r, eval = FALSE, echo = FALSE}

# 10) Create a bar chart that compares the average age of those who prefer cats vs dogs
# 
# 11) Create a scatter plot that shows the relationship between age and height (make it look nice!)
# 
# 12) Create a scatter plot that shows the relationship between height and shoe size 
# 
# 13) Create a bar chart that shows the average number of siblings for dad's mustache status.
# 
# 14) Color the barchart above and add some degree of transparency in the color. Add a title.
# 
# 15) Create a bar chart that shows the average shoe size by sex and cat/dog preference. 
# 
# 

```
