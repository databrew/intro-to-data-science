[["dataframes.html", "Module 15 Dataframes Subsetting &amp; exploring dataframes dplyr", " Module 15 Dataframes Dataframes &amp; other data structures Learning goals Practice exploring, summarizing, and filtering dataframes Understand the importance of tidy datasets Understand what the tidyverse is and why it is awesome A vector is the most basic data structure in R, and the other structures are built out of vectors. As a data scientist, the most common data structure you will be working with is a dataframe, which is essentially a spreadsheet: a dataset with rows and columns, in which each column represents is a vector of the same class of data. We will explore dataframes in detail later, but here is a sneak peak at what they look like: df &lt;- data.frame(x=300:310, y=600:610) df ## x y ## 1 300 600 ## 2 301 601 ## 3 302 602 ## 4 303 603 ## 5 304 604 ## 6 305 605 ## 7 306 606 ## 8 307 607 ## 9 308 608 ## 10 309 609 ## 11 310 610 In this command, we used the data.frame() function to combine two vectors into a dataframe with two columns named x and y. R then saved this result in a new variable named df. When we call df, R shows us the dataframe. The great thing about dataframes is that they allow you to relate different data types to each other. df &lt;- data.frame(name=c(&quot;Ben&quot;,&quot;Joe&quot;,&quot;Eric&quot;), height=c(75,73,80)) df ## name height ## 1 Ben 75 ## 2 Joe 73 ## 3 Eric 80 This dataframe has one column of class character and another of class numeric. Typically you will “read” data into Rstudio from a folder on your computer (to be covered later). However, R (and many R packages) come with built-in, clean data To see what’s available data() The two other most common data structures are matrices and lists, but we will wait on learning about those. For now, focus on becoming comfortable using vectors and dataframes. Exercise 4 Let’s create a new object named animals. This is going to be a dataframe with 4 different columns: species, height, color, veg (whether or not the animal is a vegetarian). 15.0.1 More on dataframes In data science, the most common data structure you will be using – by far – is the dataframe. You were introduced to this data structure in Module 10, but a more familiar and detailed orientation is worthwhile. Subsetting &amp; exploring dataframes To explore dataframes, let’s use a dataset on fuel mileage for all cars sold from 1985 to 2014. # need to install first install.packages(&#39;fueleconomy&#39;) library(fueleconomy) data(vehicles) head(vehicles) ## id make model year class trans ## 1 13309 Acura 2.2CL/3.0CL 1997 Subcompact Cars Automatic 4-spd ## 2 13310 Acura 2.2CL/3.0CL 1997 Subcompact Cars Manual 5-spd ## 3 13311 Acura 2.2CL/3.0CL 1997 Subcompact Cars Automatic 4-spd ## 4 14038 Acura 2.3CL/3.0CL 1998 Subcompact Cars Automatic 4-spd ## 5 14039 Acura 2.3CL/3.0CL 1998 Subcompact Cars Manual 5-spd ## 6 14040 Acura 2.3CL/3.0CL 1998 Subcompact Cars Automatic 4-spd ## drive cyl displ fuel hwy cty ## 1 Front-Wheel Drive 4 2.2 Regular 26 20 ## 2 Front-Wheel Drive 4 2.2 Regular 28 22 ## 3 Front-Wheel Drive 6 3.0 Regular 26 18 ## 4 Front-Wheel Drive 4 2.3 Regular 27 19 ## 5 Front-Wheel Drive 4 2.3 Regular 29 21 ## 6 Front-Wheel Drive 6 3.0 Regular 26 17 # View(vehicles) A dataframe has rows of data organized into columns. In this dataframe, each row pertains to a single vehicle make/model – i.e., a single observation. Each column pertains to a single type of data. Columns are named in the header of the dataframe. All the same useful exploration and subsetting functions that applied to vectors now apply to dataframes (see module 10 for a refreshers). In addition to those functions you already know, we’ve added some new functions to your inventory of useful functions. Exploration tail(vehicles) # head() and tail() summarize the beginning and end of the object ## id make model year class trans ## 33437 28868 Yugo GV Plus/GV/Cabrio 1990 Minicompact Cars Manual 4-spd ## 33438 6635 Yugo GV Plus/GV/Cabrio 1990 Subcompact Cars Manual 5-spd ## 33439 3157 Yugo GV/GVX 1987 Subcompact Cars Manual 4-spd ## 33440 5497 Yugo GV/GVX 1989 Subcompact Cars Manual 4-spd ## 33441 5498 Yugo GV/GVX 1989 Subcompact Cars Manual 5-spd ## 33442 1745 Yugo Gy/yugo GVX 1986 Minicompact Cars Manual 4-spd ## drive cyl displ fuel hwy cty ## 33437 Front-Wheel Drive 4 1.3 Regular 27 21 ## 33438 Front-Wheel Drive 4 1.3 Regular 28 23 ## 33439 Front-Wheel Drive 4 1.1 Regular 29 24 ## 33440 Front-Wheel Drive 4 1.1 Regular 29 24 ## 33441 Front-Wheel Drive 4 1.3 Regular 28 23 ## 33442 Front-Wheel Drive 4 1.1 Regular 29 22 names(vehicles) # get names of columns ## [1] &quot;id&quot; &quot;make&quot; &quot;model&quot; &quot;year&quot; &quot;class&quot; &quot;trans&quot; &quot;drive&quot; &quot;cyl&quot; &quot;displ&quot; ## [10] &quot;fuel&quot; &quot;hwy&quot; &quot;cty&quot; nrow(vehicles) # get number of rows ## [1] 33442 ncol(vehicles) # get number of columns ## [1] 12 Note that length() does not work the same on dataframes as it does with vectors. In dataframes, length() is the equivalent of ncol(); it will not give you the number of rows in a dataset. Checking for NAs # is.na(vehicles) any(is.na(vehicles)) # at least one! # Find the NA any(is.na(vehicles$id)) any(is.na(vehicles$make)) Subsetting Recall that dataframes are filtered by row and/or column using this format: dataframe[rows,columns]. To get the third element of the second column, for example, you type dataframe[3,2]. vehicles[3,2] ## [1] &quot;Acura&quot; Note that the comma is necessary even if you do not want to specify columns. If you try to type this … vehicles[3] …R will assume you are asking for the third column, not the third row. To filter a dataframe to multiple values, you can specify vectors for the row and column vehicles[1:3,11:12] # can use colons ## hwy cty ## 1 26 20 ## 2 28 22 ## 3 26 18 vehicles[1:3,c(1,11:12)] # can use c() ## id hwy cty ## 1 13309 26 20 ## 2 13310 28 22 ## 3 13311 26 18 Columns can also be called according to their names. Use the $ sign to specify a column. vehicles$hwy[1:5] ## [1] 26 28 26 27 29 Note that when you use a $, you will not need to use a comma within your brackets. If you try to run this … vehicles$hwy[1:5,] …R will throw a fit. You can use logical tests to filter dataframes to rows that meet certain conditions. For example, to filter to only the rows for cars with better than 100 mpg, you can use this syntax: keeps &lt;- which(vehicles$hwy &gt; 100) keeps ## [1] 6533 10613 10614 16429 16430 24487 24488 24489 28628 vehicles[keeps,] ## id make model year class ## 6533 33640 Chevrolet Spark EV 2014 Subcompact Cars ## 10613 33396 Fiat 500e 2013 Minicompact Cars ## 10614 34392 Fiat 500e 2014 Minicompact Cars ## 16429 33265 Honda Fit EV 2013 Small Station Wagons ## 16430 33905 Honda Fit EV 2014 Small Station Wagons ## 24487 33558 Nissan Leaf 2013 Midsize Cars ## 24488 34699 Nissan Leaf 2014 Midsize Cars ## 24489 34918 Nissan Leaf 2015 Midsize Cars ## 28628 33307 Scion iQ EV 2013 Minicompact Cars ## trans drive cyl displ fuel ## 6533 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 10613 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 10614 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 16429 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 16430 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 24487 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 24488 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 24489 Automatic (A1) Front-Wheel Drive NA NA Electricity ## 28628 Automatic (variable gear ratios) Front-Wheel Drive NA NA Electricity ## hwy cty ## 6533 109 128 ## 10613 108 122 ## 10614 108 122 ## 16429 105 132 ## 16430 105 132 ## 24487 102 129 ## 24488 101 126 ## 24489 101 126 ## 28628 105 138 But the above is a long-winded way of doing this. You can also achieve this result as follows: vehicles[which(vehicles$hwy &gt; 100),] You can also get the same result without the which() function: vehicles[vehicles$hwy &gt; 100,] The logical test is returning a bunch of TRUEs and FALSEs, one for each row of vehicles. Only the TRUE rows will be returned. Exercise 1: Reading for errors What is wrong with these commands? Why will each of them throw an error if you run them, and how can you fix them? # 1 vehicles[1,15,] # 2 vecihles[1:5,] # 3 vehicles$hwy[1:5,] # 4 vehicles[1:5,1:13] Summarizing The same summary functions that you have used for vectors work for dataframes, such as: min(vehicles$hwy) ## [1] 9 max(vehicles$hwy) ## [1] 109 mean(vehicles$cty) ## [1] 17.491 sd(vehicles$cty) ## [1] 5.582174 str(vehicles$make) ## chr [1:33442] &quot;Acura&quot; &quot;Acura&quot; &quot;Acura&quot; &quot;Acura&quot; &quot;Acura&quot; &quot;Acura&quot; &quot;Acura&quot; ... class(vehicles$hwy) ## [1] &quot;numeric&quot; You can also use the summary() function, which provides summary statistics for each column in your dataframe: summary(vehicles) ## id make model year ## Min. : 1 Length:33442 Length:33442 Min. :1984 ## 1st Qu.: 8361 Class :character Class :character 1st Qu.:1991 ## Median :16724 Mode :character Mode :character Median :1999 ## Mean :17038 Mean :1999 ## 3rd Qu.:25265 3rd Qu.:2008 ## Max. :34932 Max. :2015 ## ## class trans drive cyl ## Length:33442 Length:33442 Length:33442 Min. : 2.000 ## Class :character Class :character Class :character 1st Qu.: 4.000 ## Mode :character Mode :character Mode :character Median : 6.000 ## Mean : 5.772 ## 3rd Qu.: 6.000 ## Max. :16.000 ## NA&#39;s :58 ## displ fuel hwy cty ## Min. :0.000 Length:33442 Min. : 9.00 Min. : 6.00 ## 1st Qu.:2.300 Class :character 1st Qu.: 19.00 1st Qu.: 15.00 ## Median :3.000 Mode :character Median : 23.00 Median : 17.00 ## Mean :3.353 Mean : 23.55 Mean : 17.49 ## 3rd Qu.:4.300 3rd Qu.: 27.00 3rd Qu.: 20.00 ## Max. :8.400 Max. :109.00 Max. :138.00 ## NA&#39;s :57 The function unique() returns unique values within a column: unique(vehicles$fuel) ## [1] &quot;Regular&quot; &quot;Premium&quot; ## [3] &quot;Diesel&quot; &quot;Premium or E85&quot; ## [5] &quot;Electricity&quot; &quot;Gasoline or E85&quot; ## [7] &quot;Premium Gas or Electricity&quot; &quot;Gasoline or natural gas&quot; ## [9] &quot;CNG&quot; &quot;Midgrade&quot; ## [11] &quot;Regular Gas and Electricity&quot; &quot;Gasoline or propane&quot; ## [13] &quot;Premium and Electricity&quot; Finally, the order() function helps you sort a dataframe according to the values in one of its columns. vehicles_sorted &lt;- vehicles[order(vehicles$hwy), #sort dataframe by highway mileage c(2,3,4,10:12)] # only keep certain columns head(vehicles_sorted) ## make model year fuel hwy cty ## 397 Aston Martin Lagonda 1985 Regular 9 7 ## 398 Aston Martin Lagonda 1985 Regular 9 7 ## 406 Aston Martin Saloon/Vantage/Volante 1985 Regular 9 7 ## 408 Aston Martin Saloon/Vantage/Volante 1985 Regular 9 7 ## 27725 Rolls-Royce Camargue 1987 Regular 9 7 ## 27726 Rolls-Royce Continental 1987 Regular 9 7 Reverse the order by wrapping rev() around the order() call: vehicles_sorted &lt;- vehicles[rev(order(vehicles$hwy)), c(2,3,4,10:12)] head(vehicles_sorted) ## make model year fuel hwy cty ## 6533 Chevrolet Spark EV 2014 Electricity 109 128 ## 10614 Fiat 500e 2014 Electricity 108 122 ## 10613 Fiat 500e 2013 Electricity 108 122 ## 28628 Scion iQ EV 2013 Electricity 105 138 ## 16430 Honda Fit EV 2014 Electricity 105 132 ## 16429 Honda Fit EV 2013 Electricity 105 132 Building dataframes To create a new dataframe, use the data.frame() function. my_vehicles &lt;- data.frame(car=paste(vehicles$make,vehicles$model), mgp_hwy=vehicles$hwy, mpg_city=vehicles$cty) my_vehicles[100:106,] ## car mgp_hwy mpg_city ## 100 Acura Legend 23 15 ## 101 Acura Legend 22 17 ## 102 Acura Legend 23 16 ## 103 Acura Legend 21 16 ## 104 Acura Legend 22 17 ## 105 Acura Legend 23 16 ## 106 Acura Legend 24 16 Note how the columns were named in the data.frame() call, and that each column is separated by a comma. You can also stage an empty dataframe, which sounds useless but will become very useful as you start working with for loops and other higher-order R tools. df &lt;- data.frame() df ## data frame with 0 columns and 0 rows To coerce an object into a format that R interprets as a dataframe, use as.dataframe(): df &lt;- as.data.frame(vehicles) df[1:4,1:4] ## id make model year ## 1 13309 Acura 2.2CL/3.0CL 1997 ## 2 13310 Acura 2.2CL/3.0CL 1997 ## 3 13311 Acura 2.2CL/3.0CL 1997 ## 4 14038 Acura 2.3CL/3.0CL 1998 You can bind multiple dataframes together using rbind(): df1 &lt;- data.frame(name=c(&quot;Ben&quot;,&quot;Joe&quot;,&quot;Eric&quot;,&quot;Isabelle&quot;),instrument=c(&quot;Nose harp&quot;,&quot;Concertina&quot;,&quot;Ukelele&quot;,&quot;Drums&quot;)) df1 ## name instrument ## 1 Ben Nose harp ## 2 Joe Concertina ## 3 Eric Ukelele ## 4 Isabelle Drums df2 &lt;- data.frame(name=c(&quot;Matthew&quot;),instrument=c(&quot;Washboard&quot;)) rbind(df1,df2) ## name instrument ## 1 Ben Nose harp ## 2 Joe Concertina ## 3 Eric Ukelele ## 4 Isabelle Drums ## 5 Matthew Washboard Note that to be combined, two dataframes have to have the exact same number of columns and the exact same column names. The only exception to this is adding a dataframe with content an empty dataframe. That can work, and that will be helpful in the R Toolbag modules ahead. df &lt;- data.frame() # stage empty dataframe df1 &lt;- data.frame(name=c(&quot;Ben&quot;,&quot;Joe&quot;,&quot;Eric&quot;,&quot;Isabelle&quot;),instrument=c(&quot;Nose harp&quot;,&quot;Concertina&quot;,&quot;Ukelele&quot;,&quot;Drums&quot;)) df &lt;- rbind(df,df1) df ## name instrument ## 1 Ben Nose harp ## 2 Joe Concertina ## 3 Eric Ukelele ## 4 Isabelle Drums You can also bind multiple dataframes together using cbind(): df1 &lt;- data.frame(name=c(&quot;Ben&quot;,&quot;Joe&quot;,&quot;Eric&quot;,&quot;Isabelle&quot;),instrument=c(&quot;Nose harp&quot;,&quot;Concertina&quot;,&quot;Ukelele&quot;,&quot;Drums&quot;)) df &lt;- data.frame(age=c(33,35,35,20), home=c(&quot;Canada&quot;,&quot;Spain&quot;,&quot;USA&quot;,&quot;USA&quot;)) df &lt;- cbind(df,df1) df ## age home name instrument ## 1 33 Canada Ben Nose harp ## 2 35 Spain Joe Concertina ## 3 35 USA Eric Ukelele ## 4 20 USA Isabelle Drums Note that to be combined, two dataframes have to have the exact same number of rows and the exact same column names. Exercise 2: Subsetting and filtering A. Subset one field according to a logical test With no more than two lines of code, get the number of Honda cars in the vehicles dataset. B. Subset one field according to a logical test for a different field. In a single line of code, show the mileages of all the Toyotas in the dataset. C. Subset a dataframe to a single subgroup In a single line of code, determine how many differet car makes/models were produced in 1995. D. Get the mean value for a subgroup of data What is the average city mileage for Subaru cars in the dataset? E. Subset a dataframe to only data from between two values According to this dataset, how many different car makes/models have been produced with highway mileages between 30 and 40 mpg? Review assignment Create a vector called people of 5 peoples names from the class. Show with code how many people are in your vector Create another vector called height which is the number of centimeters tall each of those 5 people are. Combine these two vectors into a data frame. dplyr Data scientists largely work in data frames and do things to data. This is what dplyr is optimized for. It consists of a series of “verbs” which cover 95% of what you need to do for most basic data processing tasks. The verbs filter() arrange() select() rename() distinct() mutate() summarise() sample_n() (and sample_frac()) 15.0.1.1 The pipe %&gt;% is a “pipe.” It is a way to write code without so many parenthesis. For example, what if I want to find the square root of the sum of a sample of two integers from a sequence of 10 to 20 by 2: sqrt(sum(sample(seq(10, 20, 2), 2))) ## [1] 5.477226 The above could also be written as: library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union seq(10, 20, 2) %&gt;% sample(2) %&gt;% sum %&gt;% sqrt ## [1] 5.830952 Similarly the below: mean(sd(log(1:100))) ## [1] 0.9280532 Could also be written as: 1:100 %&gt;% log %&gt;% sd %&gt;% mean ## [1] 0.9280532 It can be read as “then.” Filtering The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. To be retained, the row must produce a value of TRUE for all conditions. Note that when a condition evaluates to NA the row will be dropped, unlike base subsetting with [. library(dplyr) people &lt;- data.frame(who = c(&#39;Joe&#39;, &#39;Ben&#39;, &#39;Xing&#39;, &#39;Coloma&#39;), sex = c(&#39;Male&#39;, &#39;Male&#39;, &#39;Female&#39;, &#39;Female&#39;), age = c(35, 33, 32, 34)) men &lt;- people %&gt;% filter(sex == &#39;Male&#39;) women &lt;- people %&gt;% filter(sex == &#39;Male&#39;) Arranging Arrange means putting things in order. That is, arrange() orders the rows of a data frame by the values of selected columns. Unlike other dplyr verbs, arrange() largely ignores grouping; you need to explicitly mention grouping variables (or use .by_group = TRUE) in order to group by them, and functions of variables are evaluated once per data frame, not once per group. For example: people %&gt;% arrange(age) ## who sex age ## 1 Xing Female 32 ## 2 Ben Male 33 ## 3 Coloma Female 34 ## 4 Joe Male 35 people %&gt;% arrange(sex) ## who sex age ## 1 Xing Female 32 ## 2 Coloma Female 34 ## 3 Joe Male 35 ## 4 Ben Male 33 people %&gt;% arrange(who) ## who sex age ## 1 Ben Male 33 ## 2 Coloma Female 34 ## 3 Joe Male 35 ## 4 Xing Female 32 people %&gt;% arrange(desc(age)) ## who sex age ## 1 Joe Male 35 ## 2 Coloma Female 34 ## 3 Ben Male 33 ## 4 Xing Female 32 Selecting Select (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name (e.g. a:f selects all columns from a on the left to f on the right). You can also use predicate functions like is.numeric to select variables based on their properties. people %&gt;% select(age) ## age ## 1 35 ## 2 33 ## 3 32 ## 4 34 people %&gt;% select(sex, age) ## sex age ## 1 Male 35 ## 2 Male 33 ## 3 Female 32 ## 4 Female 34 people %&gt;% select(sex, years = age) ## sex years ## 1 Male 35 ## 2 Male 33 ## 3 Female 32 ## 4 Female 34 Renaming rename() changes the names of individual variables using new_name = old_name syntax; rename_with() renames columns using a function. people %&gt;% rename(gender = sex, years = age, first_name = who) ## first_name gender years ## 1 Joe Male 35 ## 2 Ben Male 33 ## 3 Xing Female 32 ## 4 Coloma Female 34 Mutating mutate() adds new variables and preserves existing ones; transmute() adds new variables and drops existing ones. New variables overwrite existing variables of the same name. Variables can be removed by setting their value to NULL. people %&gt;% mutate(agein2020 = age - 1) ## who sex age agein2020 ## 1 Joe Male 35 34 ## 2 Ben Male 33 32 ## 3 Xing Female 32 31 ## 4 Coloma Female 34 33 people %&gt;% mutate(is_male = sex == &#39;Male&#39;) ## who sex age is_male ## 1 Joe Male 35 TRUE ## 2 Ben Male 33 TRUE ## 3 Xing Female 32 FALSE ## 4 Coloma Female 34 FALSE people %&gt;% mutate(who = NULL) ## sex age ## 1 Male 35 ## 2 Male 33 ## 3 Female 32 ## 4 Female 34 people %&gt;% mutate(average_age = mean(age)) ## who sex age average_age ## 1 Joe Male 35 33.5 ## 2 Ben Male 33 33.5 ## 3 Xing Female 32 33.5 ## 4 Coloma Female 34 33.5 people %&gt;% mutate(average_age = mean(age)) %&gt;% mutate(diff_from_avg = age - average_age) ## who sex age average_age diff_from_avg ## 1 Joe Male 35 33.5 1.5 ## 2 Ben Male 33 33.5 -0.5 ## 3 Xing Female 32 33.5 -1.5 ## 4 Coloma Female 34 33.5 0.5 Grouping Most data operations are done on groups defined by variables. group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed “by group.” ungroup() removes grouping. people %&gt;% group_by(sex) %&gt;% mutate(average_age_for_sex = mean(age)) ## # A tibble: 4 x 4 ## # Groups: sex [2] ## who sex age average_age_for_sex ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Joe Male 35 34 ## 2 Ben Male 33 34 ## 3 Xing Female 32 33 ## 4 Coloma Female 34 33 people %&gt;% group_by(sex) %&gt;% mutate(average_age_for_sex = mean(age)) %&gt;% mutate(diff_from_avg_for_sex = age - average_age_for_sex) ## # A tibble: 4 x 5 ## # Groups: sex [2] ## who sex age average_age_for_sex diff_from_avg_for_sex ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Joe Male 35 34 1 ## 2 Ben Male 33 34 -1 ## 3 Xing Female 32 33 -1 ## 4 Coloma Female 34 33 1 Summarizing summarise() or summarize() creates a new data frame. It will have one (or more) rows for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarising all observations in the input. It will contain one column for each grouping variable and one column for each of the summary statistics that you have specified. people %&gt;% summarise(average_age = mean(age)) ## average_age ## 1 33.5 people %&gt;% summarise(average_age = mean(age), standard_dev_of_age = sd(age), oldest_age = max(age), youngest_age = min(age)) ## average_age standard_dev_of_age oldest_age youngest_age ## 1 33.5 1.290994 35 32 people %&gt;% group_by(sex) %&gt;% summarise(avg_age = mean(age), oldest_age = max(age), total_years = sum(age)) ## # A tibble: 2 x 4 ## sex avg_age oldest_age total_years ## * &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Female 33 34 66 ## 2 Male 34 35 68 people %&gt;% group_by(sex) %&gt;% summarise(sample_size = n()) ## # A tibble: 2 x 2 ## sex sample_size ## * &lt;fct&gt; &lt;int&gt; ## 1 Female 2 ## 2 Male 2 Review exercise Run the below code. library(dplyr) library(babynames) bn &lt;- babynames Crete a dataframe named `turn_of_century. This should be data on baby names for the year 1900 Create a dataframe named boys. This should be only males Create a dataframe named moms_gen. This should be females born in the year of birth of your mom. Order moms_gen by n, in ascending order (ie, the least popular name at top). Look at the result; what is the least popular name among women the year your mom was born? Reverse the order and save the result into an object named moms_gen_ordered. Create an object named boys2k. This should be all males born in the year 2000. Arrange boys2k from most to least popular. What was the most popular boys name in 2000? What percentage of boys were named Joseph in 2000? Were there more Jims or Matthews in 2020? How many people were born with your name in 2020. Group activity Using the deaths data, we’re going to answer some questions together. Start with: library(readr) df &lt;- read_csv(&#39;https://raw.githubusercontent.com/databrew/intro-to-data-science/main/data/deaths.csv&#39;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## PassengerId = col_double(), ## Survived = col_double(), ## Pclass = col_double(), ## Name = col_character(), ## Sex = col_character(), ## Age = col_double(), ## SibSp = col_double(), ## Parch = col_double(), ## Ticket = col_character(), ## Fare = col_double(), ## Cabin = col_character(), ## Embarked = col_character() ## ) library(gsheet) survey &lt;- gsheet2tbl(&#39;https://docs.google.com/spreadsheets/d/1iVt9FX9J2iv3QFKBM7Gzb9dgva70XrW1lxMV4hpekeo/edit?resourcekey#gid=204634767&#39;) "]]
